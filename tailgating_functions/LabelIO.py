try:
    import os
except ImportError as e:
    raise e


class LabelIO:
    """
    This class loads the paths to the images used throughout car detection inference, as well as the corresponding
    labels generated by the network. The output is a dictionary which includes the image names, the paths to each
    image and the corresponding label. Images without labels are filtered out
    """
    def __init__(self, labels_directory: str, image_directory: str, label_format: str = 'txt',
                 image_format: str = 'png'):
        self.label_directory = labels_directory
        self.image_directory = image_directory

        self.label_format = label_format
        self.image_format = image_format

        self.label_paths = {}  # initialise dictionary that will contain label paths
        self.image_paths = {}  # same for iamge paths

        self.inference_data_dict = self._create_mapping()  # create dictionary with data of images
        # In case the user has no access to image names, store the names in a new list
        self.valid_image_names = list(self.inference_data_dict.keys())  # List of valid image names
        self.valid_image_names.sort()  # make sure to sort in increasing order

    def _load_paths(self, directory, file_extension):
        """ Load and return a dictionary of filenames (without extension)"""
        files = os.listdir(directory)
        return {os.path.splitext(f)[0]: os.path.join(directory, f) for f in files if f.endswith(file_extension)}

    def _create_mapping(self):
        """ Create a mapping of image names to their corresponding image and label paths. """
        self.image_paths = self._load_paths(self.image_directory,
                                            f'.{self.image_format}')  # Adjust the extension as needed
        self.label_paths = self._load_paths(self.label_directory, f'.{self.label_format}')

        # Once the paths are loaded, ensure that all images have corresponding labels, and reject the ones who dont
        output_dir = {name: {'image_path': img_path, 'label_path': self.label_paths.get(name)} for name, img_path in
                      self.image_paths.items() if
                      name in self.label_paths}

        return output_dir

    def get_image_label_paths(self, image_name):
        """ Retrieve image and label paths using the image name. """
        return self.inference_data_dict.get(image_name)

    def get_image_path(self, image_name):
        """ Retrieve image and label paths using the image name. """
        return self.image_paths.get(image_name)

    def get_valid_image_names(self):
        """ Return the list of valid image names that have corresponding labels. """
        return self.valid_image_names

    def get_inference_dictionary(self):
        return self.inference_data_dict


if __name__ == "__main__":
    path_to_labels = "/home/spyros/Spyros/temp_repos/SMOKE/datasets/kitti/smoke_predictions/predictions"
    path_to_images = "/home/spyros/Spyros/temp_repos/SMOKE/datasets/kitti/testing/image_2"
    label_loader = LabelIO(labels_directory=path_to_labels, image_directory=path_to_images)

    # Example of fetching image and label paths:
    image_name = '000001'  # Assume the image is named '000001.png' and the label is '000001.txt'
    paths = label_loader.get_image_label_paths(image_name)
    image_path = label_loader.get_image_path(image_name)
    print(paths)
    print(image_path)

    # Retrieve list of image names with corresponding labels:
    valid_image_names = label_loader.get_valid_image_names()
    print(valid_image_names)
